---
phase: 03-platform-constraints
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .claude/data-warehouse/context/platform/index.md
  - .claude/data-warehouse/context/platform/hive-constraints.md
autonomous: true

must_haves:
  truths:
    - "用户能识别所有会导致数据错误的 P0 Hive 约束"
    - "用户能获取每个约束的具体规避方案和代码示例"
    - "用户能通过索引页快速定位所有平台约束"
    - "用户能理解违反约束的后果（数据丢失/执行失败/性能下降）"
  artifacts:
    - path: ".claude/data-warehouse/context/platform/index.md"
      provides: "平台约束库索引页"
      contains: "约束速查表"
      min_lines: 80
    - path: ".claude/data-warehouse/context/platform/hive-constraints.md"
      provides: "Hive 3.x 平台约束文档"
      contains: "P0.*分区列|P0.*MERGE|P1.*分区大小"
      min_lines: 300
  key_links:
    - from: ".claude/data-warehouse/context/platform/index.md"
      to: "hive-constraints.md"
      via: "文档链接"
      pattern: "\\[.*\\]\\(.*hive-constraints\\.md\\)"
---

<objective>
创建平台约束库索引页和 Hive 平台约束文档（PLATFORM-01），建立约束文档的组织框架和 Hive 3.x 核心约束清单。

Purpose: 为后续 Phase 4-7 的代码生成提供可靠的技术决策依据，避免生成违反平台约束的 SQL/dbt 代码。

Output:
- `context/platform/index.md` - 约束索引页（速查表 + 文档列表）
- `context/platform/hive-constraints.md` - Hive 3.x 平台约束（分区/ORC/ACID/性能优化）
</objective>

<execution_context>
@./.claude/agents/gsd-executor.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md (Phase 3 section)
@.planning/STATE.md
@.planning/phases/03-platform-constraints/03-RESEARCH.md
@.planning/phases/03-platform-constraints/03-CONTEXT.md
@.claude/data-warehouse/context/methodology/index.md (参考索引页格式)
@.claude/data-warehouse/docs/prompting.md (文档规范)
</context>

<tasks>

<task type="auto">
  <name>Task 1: 创建平台目录结构与索引页</name>
  <files>
    .claude/data-warehouse/context/platform/index.md
  </files>
  <action>
创建 `context/platform/` 目录结构和索引页。

**目录结构：**
```
.claude/data-warehouse/context/platform/
├── index.md                      # 本任务创建
├── hive-constraints.md           # Task 2 创建
├── dbt-hive-limitations.md       # Plan 02 创建
└── incremental-strategies.md     # Plan 02 创建
```

**索引页内容（参考 methodology/index.md 格式）：**

1. **Frontmatter:**
   - type: context
   - title: 平台约束库索引
   - status: draft（待所有文档完成后改为 stable）
   - domain: platform
   - version: 1.0.0

2. **约束速查表（所有 P0 约束一览）：**
   | ID | 约束名称 | 等级 | 一句话说明 | 所属文档 |
   参考 RESEARCH.md 中的 "Hive 3.x 约束速查" 和 "dbt-hive 约束速查" 表格

3. **文档列表表格：**
   | 文档 | 覆盖需求 | 聚焦领域 | 一句话描述 | 状态 |
   - hive-constraints.md | PLATFORM-01 | Hive 平台约束 | 分区/ORC/ACID 约束 | planned
   - dbt-hive-limitations.md | PLATFORM-02 | dbt-hive 限制 | Snapshots/Ephemeral/分区列 | planned
   - incremental-strategies.md | PLATFORM-03 | 增量策略 | T+1/insert_overwrite/lookback | planned

4. **阅读顺序建议：**
   1. Hive 约束 → 了解平台能力边界
   2. dbt-hive 限制 → 了解适配器限制
   3. 增量策略 → 掌握 T+1 回刷模式

5. **版本信息和参考文献**

**注意：**
- 遵循 docs/prompting.md 的文档规范
- 使用中文，代码标识符保持英文
- Token 预算 < 800（索引页精简）
  </action>
  <verify>
文件存在且包含：
- Frontmatter 完整
- 约束速查表至少 8 条 P0 约束
- 文档列表 3 项
- 阅读顺序建议
  </verify>
  <done>索引页结构完整，包含速查表和文档导航</done>
</task>

<task type="auto">
  <name>Task 2: 编写 Hive 平台约束文档 (PLATFORM-01)</name>
  <files>
    .claude/data-warehouse/context/platform/hive-constraints.md
  </files>
  <action>
编写 Hive 3.x 平台约束文档，按风险等级组织。

**文档结构（遵循 CONTEXT.md 决策）：**

1. **Frontmatter:**
   - type: context
   - title: Hive 3.x 平台约束
   - status: stable
   - domain: platform/hive
   - version: 1.0.0

2. **TL;DR:**
   - 3-5 条最关键的 P0 约束一句话总结
   - 核心观点：Hive 非 ACID 模式下，分区回刷是唯一可靠的增量策略

3. **约束速查表（本文档约束汇总）:**
   | ID | 约束名称 | 等级 | 详情链接 |

4. **分区约束章节：**
   每个约束使用统一模板（来自 RESEARCH Pattern 1）：

   ### [P0/P1/P2] 约束名称
   **约束 ID:** HIVE-001
   **原因:** 为什么存在这个约束
   **违反后果:** 数据错误/执行失败/性能下降
   **规避方案:** 步骤列表
   **示例:**
   ❌ 错误写法 + ✓ 正确写法

   **必须包含的分区约束（来自 RESEARCH）：**
   - [P0] HIVE-001: 动态分区列必须在 SELECT 末尾
   - [P0] HIVE-002: 分区列 dt 必须 NOT NULL
   - [P0] HIVE-003: 分区列 dt 必须为 yyyy-MM-dd 格式
   - [P0] HIVE-004: 禁止并发回刷同一分区
   - [P1] HIVE-005: 分区大小应 >= 1GB
   - [P1] HIVE-006: 查询分区数不超过 1000

5. **ORC 存储约束章节：**
   - [P1] HIVE-007: 避免小文件 (<128MB)
   - [P1] HIVE-008: 定期合并小文件
   - [P2] HIVE-009: 高频点查列配置 Bloom Filter

6. **ACID 约束章节：**
   - [P0] HIVE-010: MERGE 仅支持 ACID 表
   - [P0] HIVE-011: UPDATE/DELETE 仅支持 ACID 表
   - [P0] HIVE-012: ACID 表不支持 INSERT OVERWRITE
   - [P1] HIVE-013: ACID 表有 compaction 性能开销

7. **数据完整性约束（来自 Codex Review）：**
   - [P0] HIVE-014: 禁止 SELECT *（列漂移风险）
   - [P0] HIVE-015: 分区内业务键去重（取最新版本）
   - [P0] HIVE-016: Schema 变更合同（仅允许追加列）

8. **性能优化约束章节（独立章节）：**

   ### [P1] HIVE-017: JOIN 顺序优化
   **约束 ID:** HIVE-017
   **原因:** Hive 默认左表流式处理、右表加载内存，大表在左侧导致内存溢出
   **违反后果:** 任务 OOM 或执行时间成倍增加
   **规避方案:**
   1. 小表 JOIN 大表：小表放左侧
   2. 使用 MAPJOIN hint：/*+ MAPJOIN(small_table) */
   **示例:**
   ❌ 错误写法:
   ```sql
   SELECT * FROM fact_orders o  -- 10亿行
   JOIN dim_users u ON o.user_id = u.id  -- 100万行
   ```
   ✓ 正确写法:
   ```sql
   SELECT /*+ MAPJOIN(u) */ *
   FROM dim_users u  -- 小表放左侧
   JOIN fact_orders o ON u.id = o.user_id
   ```

   ### [P0] HIVE-018: 分区裁剪优化
   **约束 ID:** HIVE-018
   **原因:** 不使用分区条件会触发全表扫描，消耗大量资源
   **违反后果:** 查询超时、集群资源耗尽
   **规避方案:**
   1. WHERE 条件必须包含分区列
   2. 避免分区列使用函数（破坏裁剪）
   **示例:**
   ❌ 错误写法:
   ```sql
   SELECT * FROM dwd_fact_orders WHERE year(dt) = 2026  -- 函数破坏裁剪
   ```
   ✓ 正确写法:
   ```sql
   SELECT * FROM dwd_fact_orders WHERE dt >= '2026-01-01' AND dt < '2027-01-01'
   ```

   ### [P1] HIVE-019: 列裁剪优化
   **约束 ID:** HIVE-019
   **原因:** 读取不需要的列浪费 I/O 和内存
   **违反后果:** 查询性能下降 30%-80%
   **规避方案:**
   1. 明确列出需要的列
   2. 禁止 SELECT *（与 HIVE-014 呼应）
   **示例:**
   ❌ 错误写法:
   ```sql
   SELECT * FROM dwd_fact_orders WHERE dt = '2026-01-31'
   ```
   ✓ 正确写法:
   ```sql
   SELECT order_id, user_id, order_amount, dt
   FROM dwd_fact_orders WHERE dt = '2026-01-31'
   ```

   ### [P1] HIVE-020: 避免性能反模式
   **约束 ID:** HIVE-020
   **原因:** 某些 SQL 写法导致性能急剧下降
   **违反后果:** 查询性能差、资源浪费
   **规避方案与反模式列表:**
   1. **避免 DISTINCT 全表去重** → 使用 GROUP BY 替代
   2. **避免子查询 IN 大数据集** → 改用 JOIN
   3. **避免 ORDER BY 无 LIMIT** → 必须配合 LIMIT
   4. **避免 UNION 替代 UNION ALL** → 无需去重时用 UNION ALL
   **示例:**
   ❌ 错误写法:
   ```sql
   SELECT DISTINCT user_id FROM fact_orders  -- 全表去重
   SELECT * FROM a WHERE id IN (SELECT id FROM big_table)  -- IN 大数据集
   SELECT * FROM fact_orders ORDER BY created_at  -- 无 LIMIT 排序
   ```
   ✓ 正确写法:
   ```sql
   SELECT user_id FROM fact_orders GROUP BY user_id  -- GROUP BY 替代
   SELECT a.* FROM a JOIN big_table b ON a.id = b.id  -- JOIN 替代
   SELECT * FROM fact_orders ORDER BY created_at LIMIT 1000  -- 有 LIMIT
   ```

9. **参考文献:**
   - Hive Language Manual DML
   - Hive Transactions Wiki
   - Cloudera HDP Performance Tuning

**代码示例要求：**
- 每个 P0/P1 约束必须有正/反示例
- 示例使用项目标准命名（dwd_fact_xxx, dim_xxx）
- 代码块标注 `-- Source: xxx`

**Token 预算：** < 2200（因增加性能优化章节，适当扩展）

**执行监控提示：** 本任务需编写 20 个约束，内容量较大。如执行中发现 token 超预算，可拆分为：
- Task 2a: 分区约束 + ORC 约束（HIVE-001 ~ 009）
- Task 2b: ACID 约束 + 数据完整性 + 性能优化（HIVE-010 ~ 020）
  </action>
  <verify>
文档包含：
- 约束速查表
- 至少 20 个编号约束（HIVE-001 ~ HIVE-020）
- P0 约束 >=10 个（包含性能优化中的关键约束）
- 每个约束有原因、规避方案
- P0/P1 约束有正/反代码示例
- 性能优化章节独立存在，包含 JOIN 顺序、分区裁剪、列裁剪、反模式
  </verify>
  <done>Hive 约束文档完整，覆盖分区/ORC/ACID/数据完整性/性能优化五大类</done>
</task>

<task type="auto">
  <name>Task 3: 更新索引页状态</name>
  <files>
    .claude/data-warehouse/context/platform/index.md
  </files>
  <action>
更新索引页：
1. 将 hive-constraints.md 状态从 `planned` 改为 `stable`
2. 确认约束速查表与 hive-constraints.md 中的约束 ID 一致
3. 添加 hive-constraints.md 的实际链接（如需修正）
  </action>
  <verify>
索引页显示 hive-constraints.md 状态为 stable
  </verify>
  <done>索引页与 Hive 约束文档保持同步</done>
</task>

</tasks>

<verification>
Phase 03 Plan 01 完成标准：

1. **目录结构：** `context/platform/` 目录存在
2. **索引页：** index.md 包含速查表、文档列表、阅读顺序
3. **Hive 约束文档：** hive-constraints.md 覆盖 PLATFORM-01
4. **约束数量：** >=20 个编号约束，>=10 个 P0
5. **格式规范：** 遵循统一模板（ID/原因/后果/规避/示例）
6. **代码示例：** P0/P1 约束都有正/反示例
7. **性能优化：** 独立章节覆盖 JOIN 顺序、分区裁剪、列裁剪、反模式
8. **Token 预算：** 索引页 <800, 约束文档 <2200
</verification>

<success_criteria>
- [ ] context/platform/index.md 存在且结构完整
- [ ] context/platform/hive-constraints.md 存在且覆盖 PLATFORM-01
- [ ] 约束按 P0/P1/P2 风险等级组织
- [ ] 每个约束使用统一模板
- [ ] P0/P1 约束有正/反代码示例
- [ ] 性能优化章节完整（4 个约束 HIVE-017 ~ 020）
- [ ] 文档符合 token 预算限制
</success_criteria>

<output>
完成后创建 `.planning/phases/03-platform-constraints/03-01-SUMMARY.md`
</output>
